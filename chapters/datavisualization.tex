\chapter{Combining React and D3}
\label{cha:visualization}

The most important aspect of the master's thesis is the thesis project. This chapter introduces the reader to the project implementation and the resulting prototypes that were developed during the development phase of the thesis project. A complete walk-through helps the reader to understand the implementation differences of all prototypes. Finally, the chapter introduces the reader to the performance testing methodology and the different devices that were used to benchmark the prototypes.

\section{Introduction and Motivation of the Project}

When trying to find the best combination of two libraries, developing prototypes is extremely important. Combining React and D3 in a few different ways in the thesis project ultimately lead to one prototype that then came out on top. The project was primarily realized to provide React developers with an alternative to pure D3 force implementations, which makes it possible to use D3's force simulations by writing React code. Finding a React implementation of D3's force simulation, which performs better than the vanilla D3 implementation was not the primary goal of the project.

The obvious question "Why do I even need a combination of D3 and React if I could just use pure D3 instead?" can quickly be answered. The initial idea of the project came to mind when a client requested a fully fledged React web application, which also included some complex data visualization aspects that are animated in the browser. Instead of having to implement the visualization part of the application in pure D3, the combination of React and D3 enables all developers of the project to write declarative D3 code. Using a combination layer API would then result in only one code base that has to be maintained, instead of two. Also, as mentioned before, D3 tends to become exponentially more challenging to maintain as the project grows.

\section{Project Setup}
\label{sub:projectSetup}

To be able to test multiple prototypes, one crucial aspect of the project is the force simulation builder setup. All prototypes are built on top of the simulation builder module. The module contains a few D3 specific methods that allow developers to build their own individual force simulation prototypes. All prototypes can reuse some of the already existing methods, and some new custom methods can be implemented as well.

By implementing a force simulation builder module, it is possible to ensure that all prototype D3 simulations are initialized and updated the same way. The most interesting code snippet of the module can be seen in \ref{prog:forceBuildModule}. Individual building blocks of the simulation can be piped together because the module uses a functional approach. Lines \ref{line:updater1}, \ref{line:updater2} and \ref{line:updater3} show how the updater functions for the three prototypes are composed together by using smaller force simulation function blocks.

The most important function in the module of course is the \texttt{buildForceSimulation()} method in line 42 in \ref{prog:forceBuildModule}. The options parameter has to contain a type, which is used to determine what updater function is applied to the force simulation. The functional switch case statement on line 36 in \ref{prog:forceBuildModule} decides based on the type which updater function to return. The builder function returns an instance of a D3 force simulation and the associated updater function that can be used by each prototype to update the simulation if the data changes.

Another interesting aspect of the code snippet in \ref{prog:forceBuildModule} is that the functional compositions can be nested. Lines \ref{line:composition1} and \ref{line:composition2} show the composition of two functions that in turn can then be composed with all three force simulation variants. Even though they are piped together, the result can then be piped again into every updater function composition as shown in lines \ref{line:applyForce1}, \ref{line:applyForce2}, and \ref{line:applyForce3} for example where the \texttt{applyForceHandlers} composed method is piped into the updater functions of the different prototypes. Again, the way the updater function composition is implemented ensures the equality of the force simulation initialization of all three prototypes.

Of course, since all three prototypes work fundamentally different, some custom apply functions have to be implemented to ensure the functionality of all three prototypes. Applying the custom functions is no problem, as all updater functions are functional compositions. If some custom method has to be added, it can just be applied to the function composition of the associated prototype. Line \ref{line:applyNewRefs} in \ref{prog:forceBuildModule} shows how a custom node reference applying function is composed into the updater function.

Each prototype implements the same API interface and receives its data via props. All visualization data and each setting parameter, therefore, has to be passed to the prototype component via React component props. Using props also means that the data and the settings must be updateable. The parent container which renders a prototype component must be able to update the prototype's data by just passing different props. The newly applied props, as a consequence, have to be handled correctly in each prototype individually.

\begin{program}[H]
\caption{Simple example of a React component and its usage} 
\label{prog:forceBuildModule}
\begin{JsCode}
const applyForceHandlers = pipeAppliers( /+\label{line:composition1}+/
  applyGeneralForce, 
  applyLinkForce, 
  applyCollisionForce
)

const applyEndHandlers = pipeAppliers( /+\label{line:composition2}+/
  applyOnEndHandler, 
  applySimulationReheating
)

const pureD3Updater = pipeAppliers( /+\label{line:updater1}+/
  applyNewNodeData,
  applyPureD3Selection, /+\label{line:applyPureD3Selection}+/
  applyTickHandler,
  applyForceHandlers, /+\label{line:applyForce1}+/
  applyDragHandlers,
  applyEndHandlers,
)

const hybridUpdater = pipeAppliers( /+\label{line:updater2}+/
  applyNewNodeData,
  applyNewRefs, /+\label{line:applyNewRefs}+/
  applyTickHandler,
  applyForceHandlers, /+\label{line:applyForce2}+/
  applyDragHandlers,
  applyEndHandlers,
)

const pureReactUpdater = pipeAppliers( /+\label{line:updater3}+/
  applyNewNodeData, 
  applyForceHandlers, /+\label{line:applyForce3}+/
  applyEndHandlers
)

const getUpdaterFunction = switchCase({
  [SIMULATION_TYPE.PURE_D3]: pureD3Updater,
  [SIMULATION_TYPE.REACT_D3_HYBRID]: hybridUpdater,
  [SIMULATION_TYPE.PURE_REACT]: pureReactUpdater,
})(null)

export const buildForceSimulation = (options) => {
  const simulation = forceSimulation()
  const updateSimulation = getUpdaterFunction(options.type)
  updateSimulation({ simulation, options })
  return { simulation, updateSimulation }
}
\end{JsCode}
\end{program}

%% DATA ENCAPSULATION %%

\section{Prototypes}

This section introduces the reader to the prototypes of the thesis project. It also explains how the project initially originated. Furthermore, every resulting prototype of the project is listed and explained extensively. All in all, the thesis project yielded 3 viable prototypes that are described in this chapter. 

%% ----------------------------------------------------------------------------------------- %%
%% ---------------------------------------- PURE D3 ---------------------------------------- %% 
%% ----------------------------------------------------------------------------------------- %%

\subsection{Pure D3 Prototype}
\label{sec:pureD3prototype}

\begin{figure}
\centering
\includegraphics[scale=.6, trim= 4cm 0 4cm 0, clip, width=1\columnwidth]{impl001.pdf}
\caption{Pure D3 force graph life cycle visualization}
\label{fig:pureD3Lifecycle}
\end{figure}

The first prototype of the project was developed from an experimental implementation. The sole reason it was realized was to test if it is even possible to combine React and D3 but still maintaining React's philosophy of unidirectional dataflow and idempotent render function components. The main goal, therefore, was to create a prototype that would always correctly update itself and thus visualize current data props each render cycle. If the parent component updated the visualization component's data or options, the prototype would have to reflect the changes as well instantly. The main difficulty with this prototype is to combine React's declarative approach with D3's imperative way of rendering data.

The implementation heavily relies on the fact, that React's reconciliation algorithm omits updates to the DOM if the same element is rendered consecutively. The pure D3 graph component only renders a static base SVG, as shown in the code snippet in \ref{prog:pureD3render}. After the component mounts, D3 hooks into the base SVG component via the provided ID and builds its force simulation on top. D3 also appends and removes the DOM nodes according to the data that was passed to D3. Figure \ref{fig:pureD3Lifecycle} demonstrates via color coding how React only renders the SVG element and D3 renders the simulation via the tick function.

\begin{program}
\caption{Render function of the pure D3 prototype}
\label{prog:pureD3render}
\begin{JsCode}
render() {
  const { width, height } = this.props
  return <svg ref={this.ref} width={width} height={height} />
}
\end{JsCode}
\end{program}

As a result, React's reconciliation algorithm does not handle nodes that are inside the D3 force simulation if the data changes. The component only renders a static SVG element that is not updated. Because the SVG element is static, React's reconciliation algorithm does not commit anything to the DOM since every time the render function is called the SVG tag stays the same. Instead, D3 entirely takes over the DOM manipulation and adequately handles the simulation by itself without React interfering in any way.

Every time the data updates, the new data is provided directly to D3 via the life cycle method \texttt{componentDidUpdate()} as figure \ref{fig:pureD3Lifecycle} shows. Of course, each data update causes React to render the base SVG component, but due to the virtual DOM implementation of React, the SVG is never newly rendered, as it is static. A static component is a React node, that does not contain any dynamic content and is therefore never updated by the reconciliation phase. React's reconciliation algorithm prevents the browser from newly committing the SVG tag to the DOM. D3, therefore, works completely separate from React. D3, on the other hand, can be implemented like on any other web project as well. Developers not only have to implement the initial force graph generation functionality but also the update logic that handles the updated data and applies it to the force graph simulation.

There are two component life cycle methods from React that are crucial to this implementation. First, \texttt{componentDidMount()} is used to initialize D3, select the base node, and then build the whole force simulation on top as demonstrated in \ref{fig:pureD3Lifecycle}. It is important to use the life cycle method that triggers \emph{after} the initial commit phase, as it makes sure, the component has already been rendered once for D3 to being able to select the existing real SVG DOM node. Looking at figure \ref{fig:pureD3Lifecycle} again, it is apparent that the second important life cycle method is \texttt{componentDidUpdate()} which provides the latest most up to date data directly to D3. That way D3 can then handle the update in the force graph.

\subsubsection{Implementation Details}

Once the component is initialized, the \texttt{componentDidMount()} life cycle method directly calls the initializer function which can be seen on line \ref{line:initGraphFn} in the code snippet in \ref{prog:pureD3InitFn}. The initializing function appends the base \texttt{<g>} tag and also handles the translation of the current height and width of the component. Then the \texttt{buildForceSimulation()} function is called with the current options and parameters in order to get the simulation and the correct updater function. Note how the simulation type is passed to the builder function as well. The resulting simulation and updater function is then saved in the current component.

\begin{program}
\caption{Pure D3 force graph initializing function}
\label{prog:pureD3InitFn}
\begin{JsCode}
initGraph = () => { /+\label{line:initGraphFn}+/
  const { width, height, onSimulationStart } = this.props

  onSimulationStart()

  const svg = select(this.ref.current)
  svg
    .append('g')
    .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')')

  const simOptions = this.extractSimOptions()
  const { simulation, updateSimulation } = buildForceSimulation({ /+\label{line:buildForceSimulation}+/
    type: SIMULATION_TYPE.PURE_D3,
    ...simOptions,
  })

  this.simulation = simulation /+\label{line:thisContext1}+/
  this.updateSimulation = updateSimulation /+\label{line:thisContext2}+/
}
\end{JsCode}
\end{program}

What is also worth mentioning is the fact, that the simulation and the updating function are saved directly to the \texttt{this} context as seen in lines \ref{line:thisContext1} and \ref{line:thisContext2} of the code snippet in \ref{prog:pureD3InitFn}. As stateful components are just plain JavaScript classes, they are capable of having member variables as well. It is of utmost importance not to confuse member variables with React's component state, as React is agnostic to class member variables. React not noticing the member variables is a wanted effect in this case, as the simulation and the updater function have to be saved in the component without React going through a new render cycle. 

Looking at the code in \ref{prog:pureD3updateApply}, the update applying functionality can be seen very well. If given a current simulation object, the function handles all newly entering, transitioning, and exiting nodes accordingly. Even an animation is applied. Each time, the pure D3 React component has goes through the \texttt{componentDidUpdate()} function, the \texttt{applyNodeUpdateCycle()} function is called as well. The force simulation building module can take in the updater function from the example in \ref{prog:pureD3updateApply} and composes it directly into the updating function as seen in line \ref{line:applyPureD3Selection} in \ref{prog:forceBuildModule}.

\begin{program}[th]
\caption{Function that applies the data update to D3 on data changes}
\label{prog:pureD3updateApply}
\begin{JsCode}
applyNodeUpdateCycle = (simulation) => {
  simulation.linkSel.exit().remove()
  
  simulation.linkSel = simulation.linkSel
    .enter()
    .append('path')
    .attr('stroke', '#45b29d')
    .attr('fill', 'none')
    .merge(simulation.linkSel)
  
  let t = transition().duration(750)
  
  simulation.nodeSel
    .exit()
    .style('fill', '#b26745')
    .transition(t)
    .attr('r', 1e-6)
    .remove()
  
  simulation.nodeSel
    .transition(t)
    .style('fill', '#3a403d')
    .attr('r', ({ size }) => size)
  
  simulation.nodeSel = simulation.nodeSel
    .enter()
    .append('circle')
    .style('fill', '#45b29d')
    .attr('r', ({ size }) => size)
    .attr('id', ({ name }) => name)
    .merge(simulation.nodeSel)
}
\end{JsCode}
\end{program}

Another vital function of the pure D3 force graph is the tick handler that can be seen in the code snippet in \ref{prog:pureD3Tick}. The ticking function also gets passed to the force simulation builder function. Each iteration of D3's simulation tick the function then updates the position of all nodes and links in the simulation.

\begin{program}[th]
\caption{Tick handling function of the pure D3 prototype}
\label{prog:pureD3Tick}
\begin{JsCode}
ticked = () => {
  this.simulation.nodeSel.attr('cx', ({ x }) => x).attr('cy', ({ y }) => y)
  this.simulation.linkSel.attr('d', (d) =>
    this.props.linkType === LINK_TYPES.CURVED ? getCurvedLinkPath(d) : getStraightLinkPath(d),
  )
}
\end{JsCode}
\end{program}

\subsubsection{Advantages}

One of the most apparent advantages of the pure D3 force graph implementation is its performance, of course. Since the implementation uses a native D3 approach to render and update the nodes and links in the simulation, the performance is also comparable to a native D3 implementation. In chapter \ref{cha:performance}, the performance is compared to other implementations as well.

\subsubsection{Disadvantages}

The most significant disadvantage with the pure D3 implementation is the fact that all DOM manipulations are handled via imperatively chained function calls on the node selections of D3 which also implies, that the node rendering cannot be customized via passing custom render functions for instance. The force graph's code itself has to be changed to get different node and link appearances, which leads to the previously described problem of encountering unmaintainable code over time.

%% ---------------------------------------------------------------------------------------- %%
%% -------------------------------------- PURE REACT -------------------------------------- %% 
%% ---------------------------------------------------------------------------------------- %%

\subsection{Pure React Prototype}
\label{sec:pureReactPrototype}

\begin{figure}
\centering
\includegraphics[scale=.6, trim= 4cm 0 2cm 0, clip, width=1\columnwidth]{impl002.pdf}
\caption{Pure React force graph life cycle visualization}
\label{fig:pureReactLifecycle}
\end{figure}

The pure React force graph implementation is far more complicated than the pure D3 force graph, as the D3 implementation is just a React wrapper for D3. To achieve a pure React implementation, D3 needs to be deeply integrated into the rendering cycle of React itself though. As mentioned in chapter \ref{cha:d3js}, D3 provides developers a tick function when using animated simulations. This tick function is executed as often as the browser has an animation frame available according to D3's documentation in \cite[/d3-timer/blob/master/README.md]{D3Github}. Explaining the request animation frame functionality of the browser would go out of the scope of this thesis, but MDN provides a good explanation on the MDN website in \cite{RAF}.

As figure \ref{fig:pureReactLifecycle} shows, the complete presentation layer is handled by React itself. The whole SVG component tree is therefore completely rendered by React. The figure also demonstrates how the data is handled not only in the component's constructor but also in its \texttt{shouldComponentUpdate()} life cycle method. As mentioned in the previous chapter \ref{cha:react}, the constructor is the first life cycle method that is executed in any React component. The pure React prototype takes advantage of that fact and initializes the complete D3 force simulation before any data is rendered. The \texttt{shouldComponentUpdate()} life cycle is used to determine if the component's props have changed and possibly apply an update to the D3 force simulation.

The key to the integration of D3 into React's render cycle is the tick function on the D3 force simulation. Every time the tick function is executed, the applied tick handler then queries the force simulation data, fetches all link and node positions, calculates the current position and then pass the newly calculated data to the React component again via a \texttt{setState()} call. Figure \ref{fig:pureReactLifecycle} demonstrates how the data flows back into the component again after each tick cycle of the force simulation.

Keeping all node and link positions in the React component state, as a result, unlocks full control to the presentation layer. Thus, React acting as a function of state can completely handle each element in the force simulation. The component state includes not only appearance properties like background or stroke color but also exact node and link positions. As a consequence, the data has to pass the complete rendering cycle of React on every tick execution, including the reconciliation phase, which can lead to poor rendering performance. Not only does it take time for D3 to calculate a new version of the force data each tick, but also React then has to process the whole new data tree. If the simulation contains a high number of nodes, the whole rendering process, which figure \ref{fig:pureReactLifecycle} shows, can massively impact performance as described later in chapter \ref{cha:performance}.

An existing project of Uber\footnote{https://www.uber.com} strongly inspired the pure React implementation. Uber's project is called vis-force and can be found on its git page in \cite{UberVisForce}. During the research phase of the thesis project, Uber's project was found and also thoroughly examined. The pure React prototype implementation is essential as it can be used to compare the render performance to the other two prototypes of the thesis project.

\subsubsection{Implementation Details}

The initialization of the pure React force graph pretty much looks the same as in line \ref{line:buildForceSimulation} in the pure D3 code example in \ref{prog:pureD3InitFn}. The pure React prototype passes the correct according simulation type of course though. The biggest and most important difference to the pure D3 implementation is that the initialization of the force simulation takes place inside the constructor instead of the \texttt{componentDidMount()} life cycle method. As mentioned before, the pure React prototype contains all node and link positions in the internal state. Consequently, the internal state must exist before calling the \texttt{render()} life cycle method the first time.

Due to the fact, that the pure React force graph component provides the complete dataset about all nodes and links in the simulation, the render function can be 100\% declarative code as seen in the code example in \ref{prog:pureReactRender}. The link and node properties which contain presentational data like the size of a node or the color of a link come from the component's props, as they are passed in from the parent container. However, the link and node positions come from the components internal state. The example code in \ref{prog:pureReactRender} shows very well, how the nodes and links components have direct access to the link and node positions. Figure \ref{fig:pureReactLifecycle} also shows how the React components handle all the SVG properties.

\begin{program}
\caption{Render life cycle method of the pure React force graph prototype}
\label{prog:pureReactRender}
\begin{JsCode}
render() {
  const { height, width, nodes, links } = this.props
  const { linkPositions, nodePositions } = this.state
  
  return (
    <span style={containerStyle}>
      <svg height={height} width={width}>
        <g style={gStyle} transform={`translate(${width / 2},${height / 2})`}>
          <Links links={links} linkPositions={linkPositions} />
          <Nodes nodes={nodes} nodePositions={nodePositions} />
        </g>
      </svg>
    </span>
  )
}
\end{JsCode}
\end{program}

Another vital aspect of the pure React force graph's implementation is the update handling mechanism. Due to the fact, that the component is updated on every free animation frame of the browser, it is of utmost importance to only update the component if necessary. The \texttt{shouldComponentUpdate()} function in the code snippet in \ref{prog:pureReactSimulationUpdate} shows, that not only internal state but also the props are checked, if they have updated. Only if the props provided by the parent have changed, the component calls the force simulation updater function which it obtained via the \texttt{buildForceSimulation()} call in the constructor. The component should update though if either its props or its state has changed. If the props have changed, the simulation updater function makes sure that the force simulation calculates the data for the new nodes and links. By doing so, the next render call can already process the new node and link positions.

Unfortunately calling the \texttt{handleSimulationUpdate()} function inside React's life cycle method \texttt{shouldComponentUpdate()} is considered an anti-pattern according to React's documentation in \cite[/docs/react-component.html]{React}, as side-effects should always be handled inside the \texttt{componentDidUpdate()} life cycle method. The force simulation updater function is a so-called ''side effect''. Facebook strongly advises against using any side effects in the \texttt{shouldComponentUpdate()} life cycle method, as it should be as fast and efficient as possible to prevent possible render cycles. In the case of the pure React force component calling the simulation updater function is fine though, as the side-effect is not called on every state update, but only if the component's props change. Props only change, if the parent component passes different props, which does not happen that often. The internal component state, on the other hand, updates multiple times per second and preventing the simulation update function call on every state change is crucially important for good rendering performance.

\begin{program}
\caption{Update method of the pure React force graph prototype}
\label{prog:pureReactSimulationUpdate}
\begin{JsCode}
shouldComponentUpdate(nextProps, nextState) => {
  const propsChanged = shallowCompare(this.props, nextProps)
  const stateChanged = shallowCompare(this.state, nextState)
  const shouldUpdate = propsChanged || stateChanged
  propsChanged && this.handleSimulationUpdate(nextProps)
  return shouldUpdate
}
\end{JsCode}
\end{program}

Another interesting aspect of the pure React prototype implementation is the fact, that the tick handler function does not manipulate the DOM directly as the pure D3 example does. Instead, the code example in \ref{prog:pureReactTickHandler} demonstrates how React's \texttt{setState()} component function is called which updates the component's state with the new link and node positions. The functions on lines \ref{line:getLinkPositions} and \ref{line:getNodePositions} take in the current force simulation as a parameter and extract either the node or link positions and return them. As mentioned before, the update function is called as often, as the simulation tick function ticks. 

Every \texttt{setState()} call updates the component and triggers a new render cycle of the force component. The component update loop goes on until the alpha in the simulation has fully decayed. The \texttt{updatePositions()} call on line \ref{line:updatePositions} in the code snippet in \ref{prog:pureReactTickHandler} itself is also wrapped inside a \texttt{requestAnimationFrame()} call to ensure a consistent framerate in the browser. The component updater function should only be called if the browser is ready to render a new simulation tick.

\begin{program}
\caption{Simulation tick handler of the pure React force graph prototype}
\label{prog:pureReactTickHandler}
\begin{JsCode}
updatePositions = () => { /+\label{line:updatePositions}+/
  this.setState({
    linkPositions: getLinkPaths(this.simulation), /+\label{line:getLinkPositions}+/
    nodePositions: getNodePositions(this.simulation), /+\label{line:getNodePositions}+/
  })
}
\end{JsCode}
\end{program}

\subsubsection{Advantages}

%% GRAMMARLY until here ...

A considerable advantage of a pure React implementation is the excellent developer experience. Programmers have full control over the simulation data. All force data can be represented declaratively via React components. The most significant difference to D3 is, that bigger D3 codebases often contain a significant amount of hardly maintainable code, as DOM nodes have to be added via imperative \texttt{append()} and removed via imperative \texttt{remove()} calls which exist on multiple different places in the code base. Since DOM nodes have to be conditionally added, changed, and removed, the code quickly gets confusing. When writing the components with React, the library accurately renders nodes and links that exist in the currently calculated data tree that was produced by the current ticking cycle of the D3 force simulation. React itself can completely handle not only properties like filling color or stroke properties but also the position.

Rendering the complete force graph via React components yields one other significant advantage compared to the pure D3 prototype. If desired, the force graph component can be upgraded to accept custom rendering functions that can be passed from outside. If the pure React force graph component would offer a custom rendering function, users of the component could write their rendering functions with React code to achieve a customized version of the force graph. Chapter \ref{cha:opensource} is all about how the thesis project can be open sourced.

\subsubsection{Disadvantages}

The most significant advantage sadly is also the biggest disadvantage of the pure React force graph. Because the pure React prototype not only stores all link positions in the internal component state but also updates it every fraction of a second as a consequence more CPU cycles are lost by calculating not only the D3 tick cycles but also complete React render cycles. Even though sometimes some node and link positions are only changed ever so slightly when the alpha value approaches the minimum value, React's reconciliation algorithm determines an updated DOM node and completely recommit the whole node to the DOM, which, of course, has an impact on performance.

Another considerable disadvantage of the pure React force graph implementation is, that some D3 functionalities like dragging nodes or zooming in and out of the graph have to be implemented from scratch in pure React which can be a tedious task. Due to the component being rendered multiple times a second, implementing well performing drag handlers is a very complicated task, for example.

%% ----------------------------------------------------------------------------------------- %%
%% ----------------------------------- REACT & D3 HYBRID ----------------------------------- %% 
%% ----------------------------------------------------------------------------------------- %%

\subsection{D3 and React Hybrid Prototype}
\label{sub:D3AndReactHybrid}

\begin{figure}
\centering
\includegraphics[scale=.6, trim= 4cm 0 4cm 0, clip, width=1\columnwidth]{impl003.pdf}
\caption{Pure React force graph life cycle visualization}
\label{fig:reactD3HybridLifeCycle}
\end{figure}

Last but not least, there is the D3 and React hybrid force graph component implementation. The prototype not only provides the developing experience of React but also puts the complete feature set of D3 at the developers' disposal. The hybrid implementation makes it possible to handle the representational aspect of the simulation via React and let D3 not only calculate but also manipulate the DOM node positions of the individual nodes and links in the force graph. Figure \ref{fig:reactD3HybridLifeCycle} demonstrates via color coding what parts of the DOM content are handled by React and D3. 

The way the prototype achieves the previously mentioned functionality is that the D3 force simulation is constructed \emph{after} the hybrid React component is initialized and mounted. As in the other two prototypes, all force data is passed into the hybrid force graph component via props from the parent component. React renders the nodes and links which are represented in the props' data and after the render phase has been passed, the data is then handed to D3 via the \texttt{componentDidUpdate()} life cycle method. D3 selects the already committed DOM nodes and applies the internally calculated force position data. Figure \ref{fig:reactD3HybridLifeCycle} demonstrates how only post render phase life cycle methods are used to pass data to D3.

As described in chapter \ref{cha:react}, during the component's render phase the reconciliation algorithm compares newly applied data of the component's state or props with the virtual DOM and then decides which DOM nodes need to be committed to or removed from the DOM. Once the simulation data updates via a prop update from the parent component, some nodes or links, therefore, might be added, changed or could just be removed, if they are non-existent anymore in the new version of the applied data.

The most important aspect of the hybrid prototype is that D3 selects already existing DOM nodes and connects them to the current force simulation data. Since the selection process is executed in React's commit phase, D3 can read the up to date version of the DOM. As described in chapter \ref{cha:react}, reading or manipulating the DOM in the commit phase guarantees the DOM to be a representation of the component's current state and data. Therefore D3's selection happens \emph{after} the render phase to always apply its selection to the most recent version of the DOM. Again, figure \ref{fig:reactLifecycleMethods} visualizes all of React's life cycle phases.

\subsubsection{Implementation Details}

As the name of the component already reveals, the implementation of the hybrid prototype is a combination of the previous two prototypes. The initialization of the hybrid graph component also looks very similar to the initialization on line \ref{line:buildForceSimulation} in the code snippet in \ref{prog:pureD3InitFn}. The only difference also in the hybrid implementation is that the hybrid simulation type is passed to the builder function. A very notable difference to the pure React component is, that the initializer function is called in the \texttt{componentDidMount()} life cycle method, not in the component's constructor. As described before in the introduction of subsection \ref{sub:D3AndReactHybrid}, the component needs to be in the commit phase for D3 being able to hook into already committed DOM nodes.

As described in the subsection \ref{sub:projectSetup}, the \texttt{buildForceSimulation()} function is very important to ensure every prototype the same D3 force simulation object. Any changes in given option parameters yield a different simulation of course, but the builder function is an idempotent function. If every prototype calls the builder function with the same force simulation option parameters, the method always returns the same simulation for every prototype. Like the other prototypes, the hybrid implementation of course also uses the force simulation builder function.

In contrast to the other prototypes, updating the hybrid graph component is quite simple. The code snippet in \ref{prog:hybridUpdateHandler} shows, that the \texttt{componentDidUpdate()} life cycle method just calls the updater function that was obtained from the \texttt{buildForceSimulation()} call. Since D3 handles the positioning of the nodes, updates in the components simulation data have to be passed to D3 to update its force calculation. While the pure React prototype has to pass a complete render-cycle multiple times a second, the hybrid component only updates, if the parent container passes some new simulation data. As a consequence, the hybrid component can be rendered multiple times by the parent container but prevents itself from updating via implementing the \texttt{shouldComponentUpdate()} life cycle method.

\begin{program}
\caption{Component update handler of the hybrid force graph prototype}
\label{prog:hybridUpdateHandler}
\begin{JsCode}
componentDidUpdate() {
  this.updateSimulation(this.extractSimUpdateParams())
}
\end{JsCode}
\end{program}

The tick handler, on the other hand, contains a few D3 specific instructions to display the current force simulation state. As mentioned before, the hybrid component makes D3 responsible for positioning the DOM nodes correctly according to the current simulation data. Line \ref{line:hybridTickHhandler} in the code example in \ref{prog:hybridTickHandler} demonstrates, how the tick handler works in the hybrid prototype. To enable users of the component to pass custom simulation handlers, the node and link handlers are extracted from the props of the component first. If they are set from the parent container, they are utilized to handle the simulation tick. Otherwise the standard tick handlers on lines \ref{line:applyNodeTick} and \ref{line:applyLinkTick} are used. More information on how to customize the usage of the hybrid component can be read in chapter \ref{cha:opensource} later on.

\begin{program}
\caption{Simulation tick handler of the hybrid force graph prototype}
\label{prog:hybridTickHandler}
\begin{JsCode}
applyNodeTick = (nodeSel) => nodeSel.attr('cx', (d) => d.x).attr('cy', (d) => d.y) /+\label{line:applyNodeTick}+/
applyLinkTick = (linkSel) => linkSel.attr('d', this.getLinkPath) /+\label{line:applyLinkTick}+/

ticked = () => { /+\label{line:hybridTickHhandler}+/
  const { nodeTickHandler, linkTickHandler } = this.props

  nodeTickHandler /+\label{line:decideNodeTickHandler}+/
    ? nodeTickHandler(this.simulation.nodeSel)
    : this.applyNodeTick(this.simulation.nodeSel)

  linkTickHandler /+\label{line:decideLinkTickHandler}+/
    ? linkTickHandler(this.simulation.linkSel)
    : this.applyLinkTick(this.simulation.linkSel)
}
\end{JsCode}
\end{program}

Like the pure D3 prototype, the hybrid prototype also supports transitions. To achieve D3's transition functionality, a library called "react-move" -- which can be found on its GitHub page in \cite{ReactMove} -- provides the functionality for React components. Because React only renders its current state as a function of state, it is not possible to keep track of data throughout multiple render cycles. If for example a node with index "42" exists in render cycle 1 but not in render cycle 2, there is no way for React to know, that there was a node with index "42" in the first render cycle. React move provides an animation mechanism to tackle the previously mentioned problem. All of the simulation data is passed to the react-move component inside the hybrid node component, which then keeps track of data changes via an internal system. Via animation hook functions the behaviors of entering, transitioning, and exiting nodes can be specified, which is similar to the D3 prototype. Information about the usage and how the react-move library works internally can be found on the GitHub project in \cite{ReactMove}.


\subsubsection{Advantages}

The benefit of the hybrid implementation is that React can handle the node and link representation. Writing React code also implies, that there are no disjointed code fragments of appending and removing components like in D3 code. Using React components to render the force simulation nodes also implies, that custom node components can be written and used in the force component, which makes the hybrid implementation highly versatile.

The rendering performance is quite sure close to a pure D3 implementation, as React has to render the nodes for the simulation only once every data update. D3 then takes over by altering the positions on the actual DOM nodes via its internal ticking function. Technically there is no difference between rendering the initial nodes and links of a force graph via React or D3 as the DOM nodes have to be committed nevertheless. D3's force simulation tick cycles then directly alter the position attributes of the DOM SVG nodes. React is agnostic of D3 being hooked into the DOM nodes, as the component only updates if the outside data changes. When the parent passes new simulation data, the simulation is fully updated in any case. Final numbers on performance are elaborated in chapter \ref{cha:performance} though.

\subsubsection{Disadvantages}
\label{subsub:hybridDisadvantages}

A significant disadvantage of the hybrid prototype is that it might be unclear to maintainers of the library that D3 handles the positions of the nodes and links and not React. Of course, documenting the positioning aspect could be a solution to the problem. Writing proper documentation is not only time but also resource consuming for maintainers. New maintainers of the library would have to completely understand how the hybrid combination of React and D3 works to start being productive on the library.

\section{Comparison of the Different Proposed Prototypes}

When comparing the prototypes, an essential aspect is to understand, which technology renders what part of the DOM. Looking at the pure D3 prototype, React only renders the base SVG element so D3 can hook into the SVG base node and build up its simulation. The pure React prototype, on the other hand, renders the complete DOM node tree of the whole simulation, including the different positions. Last but not least, the hybrid prototype introduces a mixed rendering strategy, where React renders the whole DOM node tree, but D3 selects the already rendered nodes and only manipulates its positions.

The performance of the pure D3 prototype should act as a baseline for testing the other prototypes, as the whole simulation is handled by standard D3 code. The pure React prototype has to iterate a whole React render cycle on each simulation tick, which technically is performing worse than letting D3 manipulate the DOM nodes directly. Therefore the hybrid prototype takes advantage of both worlds by leaving the expensive calculations and node position manipulations to D3 while Rendering the nodes with declarative React code.

Looking at the figures \ref{fig:pureD3Lifecycle}, \ref{fig:pureReactLifecycle}, and \ref{fig:reactD3HybridLifeCycle} again, they might appear to be quite similar. There are some subtle differences which make big differences though. Even though all prototypes mostly use two life cycle methods, it is of utmost importance to recall in which component life cycle phase the methods are called though. Figure \ref{fig:reactLifecycleMethods} can help to look up all common life cycle methods again. While the pure D3 and hybrid prototype pass the simulation to D3 only in the commit phase, the pure React prototype has to pass its data to D3 in the render phase.

\section{Prototype Storybook}

\begin{figure}
  \centering
  \includegraphics[width=0.89\columnwidth]{reactd3story}
  \caption{React Storybook currently showing the hybrid prototype}
  \label{fig:reactD3stroy}
\end{figure}

The thesis project furthermore contains one additional aspect that makes it quite easy to compare and test out all available prototypes. A community project called ''Storybook'' was utilized to compare and present the prototype results. The GitHub page in \cite{ReactStorybook} explains the Storybook software as a development environment for UI components. The library lets developers build component browsers for their projects which showcase the project's components in so-called "stories". A story is a self-contained page which renders a project component with a pre-applied configuration and state. In the case of the thesis project, the Storybook library was used to present all three prototypes in action and to make them interactive and browsable. 

Figure \ref{fig:reactD3stroy} shows a visualization of the Storybook, which was developed for the thesis project. Users can select a prototype and a particular configuration from the sidebar and view the result in the main content section. All components are rendered inside a state container that provides data manipulation functionalities. For instance, via a simple click, the force data can be updated, links can be toggled, data or links can be shuffled and so on. All possible data manipulation functions can be seen in figure \ref{fig:reactD3stroy} on top of the component section.

\section{Conclusion}

All in all, each prototype has an interesting implementation on its own. The implmentation of the thesis project showed, that every prototype has certain advantages and disadvantages. The question of which prototype is the best is a subjective decision in the end. An aspect that can be measured though is performance. Chapter \ref{cha:performance} shows how the particular prototypes perform in comparison to each other. As letting other developers profit from the findings of this master project is desired, the hybrid prototype will be an open source project in the near future. More information about the plans of making the newly invented hybrid prototype open source can be read in chapter \ref{cha:opensource}.