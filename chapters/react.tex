\chapter{React â€“ A JavaScript library for building user interfaces}
\label{cha:react}

This chapter introduces the reader to the very popular and widespread front end library called ReactJS. It explains an essential part of React -- its rendering cycle -- which the reader needs to understand at least on a high level to be able to follow upcoming explanations of how the thesis project was implemented. Additionally, the paper elaborates the difference of how React uses declarative code to render data, whereas D3 uses an imperative API to render its data.

\section{Introduction to ReactJS}

The easiest way to find information about React is to visit its official website \footnote{https://reactjs.org}. There is a statement in \cite{React} up front that says: \begin{quote}\begin{english}React is a JavaScript library for building user interfaces.\end{english}\end{quote} which describes React very well. A Facebook engineer called Jordan Walke founded the library in 2011 as presented in \cite[05:30]{ReactFoundingVideo}. Walke wanted to create a tool that would improve the code quality of their internal tool called ''Facebook ads''. Up until then, Facebook continued to develop and use React internally, but since the year 2013, the project is entirely open source. Since the initial open-source release up until now, not only technical engineers of Facebook but also the React open source community itself have been maintaing the library. In late 2017 Facebook even changed React's BSD license to the MIT license, which is even better for the React community, as the MIT license has lesser restrictions than the BSD license.

According to \cite{React} React sees itself as a declarative and component-based library. However, a question might come to mind: ''What exactly does it mean for a library to be declarative and component-based?''. The answer to this question might be more straightforward than initially anticipated. In \cite{lloyd1994practical} declarative programming is described as a programming pattern, that expresses the logic of a program without describing its control flow. This means that the actual code describes what has to be computed not exactly how it should be done exactly by stating every action explicitly via a function call for example. Declarative programming can be understood as a layer of abstraction, that makes software easier to understand for readers of the code. Declarative programming is therefore very different from the imperative programming pattern described in chapter \ref{cha:d3js}. React approach of handling the presentation layer is declarative since its API lets developers describe how the application has to look like at any given data variation, which is quite the contrary to D3's API as it can be read in \ref{cha:d3js}. Further information about React's API can be found in section \ref{sec:reactApi} though.

Enabling developers to create a highly component oriented architecture in their software is a fundamental aspect of React as well. Using a component-based library can increase productivity a tremendous amount. However, what does it mean for a library to favor component based architecture? After the initial setup of some boilerplate code, React makes it exceptionally easy to reuse existing components in the codebase to allow even faster development cycles. Once standard input components like buttons or text fields and layout components like page or header components are implemented, they can be reused throughout the whole app; thus significant progress can be achieved in a very short amount of time. Components can be manipulated by passing different properties, which might result in different presentation results of the components. More in-depth information about how React handles components and its props can be found in section \ref{sec:reactApi}.

React components can have multiple applications. There are presentational components for example which are pure functions that just represent the current state. Nevertheless, there are also stateful class Components though which can hold some application state and update according to state changes. React however makes no assumptions about the technology stack that is used according to \cite{React}. This means, that users of the library can decide for themselves if they want to use the built in state management functionality or if they want to use a third party library for solving specific problems like global applicaion state for example.
    
The documentation in \cite[/docs]{React} claims, that the library makes use of a so called ''virtual DOM''. This means, that React will keep track of its state data to prevent unnecessary writes to the actual DOM object. JavaScript performs exceptionally well when handling pure JavaScript objects in memory. Keeping the DOM tree of the application in the JavaScript engine's heap as a representation of objects enables React to apply data updates this so-called virtual DOM, then diff the newly applied data with the old tree to then being able to decide what DOM nodes need to be rewritten. Writing or committing to the DOM is the most expensive type of work in the browser, so React tries to keep DOM manipulating actions to a minimum. The React team calls the diffing algorithm ''reconciliation algorithm''. It would go out of the scope of this paper to go more in depth of the algorithm, so it is recommended to read about React's reconciliation algorithm in its documentation \cite[/docs]{React}.

React is a view layer that favors unidirectional data-flow. Every time the application state changes, the whole new data object is passed to React again. As mentioned in \cite[6:50]{ReactFoundingVideo}, the speaker describes the functionality very well via explaining React as a simplified function that could look like this: \texttt{f(data) = UI}. Hence, React can be seen as the view layer that handles presentation as a function of state and data. Once the data has updated the virtual dom, the virtual dom is then passed to React's reconciliation algorithm which then determines if any nodes have to be changed on the real DOM. If there would be a React component that always renders the same \texttt{<div>} with the same data, rendering that very component multiple times would not result in React writing multiple DOM nodes to the browser. The reconciliation algorithm sees that the virtual dom matches the real dom in this case, which results in React not updating the real DOM. Of course, if the component's content is dynamic, the component sometimes has to be re-rendered according to the data changes. If some parts of the data stay the same even after being reapplied to a component, only newly added or removed nodes are committed to the DOM. Even though the reconciliation algorithm prevents expensive DOM operations, the algorithm itself can also be expensive. The documentation in \cite[/docs/optimizing-performance.html\#avoid-reconciliation]{React} advises developers to try to avoid reconciliation to improve performance.

Unidirectional dataflow implicitly means for React, that there is no data binding and no template language. The library only uses \texttt{React.createElement([element])} calls internally, which are hidden behind the so called ''JSX'' javascriptt language extension. JSX will be explained more in depth in section \ref{sec:reactApi}. As mentioned before, React is just a pure function of its application state. This also means, if the application data has to be changed, a new ''patched'' version of the application data has to be created to then being feeded into React again. That is the reason why React works really well with immutable data structures. Going more indepth on how React works well with immutable state would go out of the scope of this thesis though. It is just important to know, that every time the data changes, this triggers a whole new render cycle of React.

\section{Explaining the React API}
\label{sec:reactApi}

%Another important aspect of React which is important for this project are its life cycle methods. Each component has a life cycle that will be executed on each rendering cycle. Developers can hook into those life cycle methods to implement some logic that should be executed after a component mounts or after a component was updated for example. The most well known life cycle methods of React are \texttt{componentDidMount()} or \texttt{componentDidUpdate()}.

\section{The difference between imperative and declarative APIs}


