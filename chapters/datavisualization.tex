\chapter{Data Visualization with React and D3}
\label{cha:visualization}

The most important aspect of the master's thesis is the thesis project. This chapter introduces the reader to the project implementation and the resulting prototypes that were developed during the development phase of the thesis project. A complete walk-through helps the reader to understand the implementation differences of all prototypes. Finally, the chapter introduces the reader to the performance testing methodology and the different devices that were used to benchmark the prototypes.

\section{Prototypes}

This section introduces the reader to the prototypes of the thesis project. It also explains how the project initially originated. Furthermore, every resulting prototype of the project is listed and explained extensively. All in all, the thesis project yielded 3 viable prototypes that are described in this chapter. 

\subsection{Introduction and motivation of the project}

When trying to find the best combination of two libraries, developing prototypes is extremely important. Combining React and D3 in a few different ways in the thesis project ultimately lead to one prototype that then came out on top. The project was primarily realized to provide React developers with an alternative to pure D3 force implementations, which makes it possible to use D3's force simulations by writing React code. Finding a React implementation of D3's force simulation, which performs better than the vanilla D3 implementation was not the primary goal of the project.

The obvious question "Why do I even need a combination of D3 and React if I could just use pure D3 instead?" can quickly be answered. The initial idea of the project came to mind when a client requested a fully fledged React web application, which also included some complex data visualization aspects that are animated in the browser. Instead of having to implement the visualization part of the application in pure D3, the combination of React and D3 enables all developers of the project to write declarative D3 code. Using a combination layer API would then result in only one code base that has to be maintained, instead of two. Also, as mentioned before, D3 tends to become exponentially more challenging to maintain as the project grows.

\subsection{Project setup}

\begin{program}
\caption{Simple example of a React component and its usage} 
\label{prog:forceBuildModule}
\begin{JsCode}
const applyForceHandlers = pipeAppliers(
  applyGeneralForce, 
  applyLinkForce, 
  applyCollisionForce
)

const applyEndHandlers = pipeAppliers(
  applyOnEndHandler, 
  applySimulationReheating
)

const pureD3Updater = pipeAppliers(
  applyNewNodeData,
  applyPureD3Selection,
  applyTickHandler,
  applyForceHandlers,
  applyDragHandlers,
  applyEndHandlers,
)

const hybridUpdater = pipeAppliers(
  applyNewNodeData,
  applyNewRefs,
  applyTickHandler,
  applyForceHandlers,
  applyDragHandlers,
  applyEndHandlers,
)

const pureReactUpdater = pipeAppliers(
  applyNewNodeData, 
  applyForceHandlers, 
  applyEndHandlers
)

const getUpdaterFunction = switchCase({
  [SIMULATION_TYPE.PURE_D3]: pureD3Updater,
  [SIMULATION_TYPE.REACT_D3_HYBRID]: hybridUpdater,
  [SIMULATION_TYPE.PURE_REACT]: pureReactUpdater,
})(null)

export const buildForceSimulation = (options) => {
  const simulation = forceSimulation()
  const updateSimulation = getUpdaterFunction(options.type)
  updateSimulation({ simulation, options })
  return { simulation, updateSimulation }
}
\end{JsCode}
\end{program}

To be able to test multiple prototypes, one crucial aspect of the project is the force simulation builder setup. All prototypes are built on top of the simulation builder module. The module contains a few D3 specific methods that allow developers to build their own individual force simulation prototypes. All prototypes can reuse some of the already existing methods, and some new custom methods can be implemented as well.

By implementing a force simulation builder module, it is possible to ensure that all prototype D3 simulations are initialized and updated the same way. The most interesting code snippet of the module can be seen in \ref{prog:forceBuildModule}. Individual building blocks of the simulation can be piped together because the module uses a functional approach. Lines 12, 21 and 30 show how the updater functions for the 3 prototypes are composed together by using smaller force simulation function blocks.

The most important function in the module of course is the \texttt{buildForceSimulation()} method in line 42 in \ref{prog:forceBuildModule}. The options parameter has to contain a type, which is used to determine what updater function is applied to the force simulation. The functional switch case statement on line 36 in \ref{prog:forceBuildModule} decides based on the type which updater function to return. The builder function returns an instance of a D3 force simulation and the associated updater function that can be used by each prototype to update the simulation if the data changes.

Another interesting aspect of the code snippet in \ref{prog:forceBuildModule} is that the functional compositions can be nested. Lines 1 and 7 show the composition of two functions that in turn can then be composed with all three force simulation variants. Even though they are piped together, the result can then be piped again into every updater function composition as shown in lines 16, 25, and 32 for example where the \texttt{applyForceHandlers} composed method is piped into the updater functions of the different prototypes. Again, the way the updater function composition is implemented ensures the equality of the force simulation initialization of all 3 prototypes.

Of course, since all 3 prototypes work fundamentally different, some custom apply functions have to be implemented to ensure the functionality of all 3 prototypes. Applying the custom functions is no problem, as all updater functions are functional compositions. If some custom method has to be added, it can just be applied to the function composition of the associated prototype. Line 23 in \ref{prog:forceBuildModule} shows how a custom node reference applying function is composed into the updater function.

Each prototype implements the same API interface and receives its data via props. All visualization data and each setting parameter, therefore, has to be passed to the prototype component via React component props. Using props also means that the data and the settings must be updateable. The parent container which renders a prototype component must be able to update the prototype's data by just passing different props. The newly applied props, as a consequence, have to be handled correctly in each prototype individually.

%% DATA ENCAPSULATION %%

\subsection{Pure D3 prototype}

\begin{figure}
\centering
\includegraphics[scale=.6, trim= 4cm 3cm 6cm 3cm, clip, width=1\columnwidth]{impl001.pdf}
\caption{Lifecycle of the pure D3 prototype}
\label{fig:pureD3Lifecycle}
\end{figure}

\begin{program}
\caption{Render function of the pure D3 prototype}
\label{prog:pureD3render}
\begin{JsCode}
render() {
  const { width, height } = this.props
  return <svg ref={this.ref} width={width} height={height} />
}
\end{JsCode}
\end{program}

The first prototype of the project was developed from an experimental implementation. The sole reason it was realized was to test if it is even possible to combine React and D3 but still maintaining React's philosophy of unidirectional dataflow and idempotent render function components. The main goal, therefore, was to create a prototype that would always correctly update itself and thus visualize current data props each render cycle. If the parent component updated the visualization component's data or options, the prototype would have to reflect the changes as well instantly. The main difficulty with this prototype is to combine React's declarative approach with D3's imperative way of rendering data.

The implementation heavily relies on the fact, that React's reconciliation algorithm omits updates to the DOM if the same element is rendered consecutively. The pure D3 graph component only renders a static base SVG, as shown in \ref{prog:pureD3render}. After the component mounts, D3 hooks into the base SVG component via the provided ID and builds its force simulation on top. D3 also appends and removes the DOM nodes according to the data that was passed to D3. 

As a result, React's reconciliation algorithm does not handle nodes that are inside the D3 force simulation if the data changes. The component only renders a static SVG element that is not updated. Because the SVG element is static, React's reconciliation algorithm doesn't commit anything to the DOM since every time the render function is called the SVG tag stays the same. Instead, D3 entirely takes over the DOM manipulation and adequately handles the simulation by itself without React interfering in any way.

Every time the data updates, the new data is provided directly to D3 via the lifecycle method \texttt{componentDidUpdate()} as figure \ref{fig:pureD3Lifecycle}. Of course, each data update causes React to render the base SVG component, but due to the virtual DOM implementation of React, the SVG is never newly rendered, as it is static. A static component is a React node, that does not contain any dynamic content and is therefore never updated by the reconciliation phase. React's reconciliation algorithm prevents the browser from newly committing the SVG tag to the DOM. D3, therefore, works completely separate from React. D3, on the other hand, can be implemented like on any other web project as well. Developers not only have to implement the initial force graph generation functionality but also the update logic that handles the updated data and applies it to the force graph simulation.

There are 2 component life cycle methods from React that are crucial to this implementation. First, \texttt{componentDidMount()} is used to initialize D3, select the base node, and then build the whole force simulation on top. It is important to use the life cycle method that triggers after the initial commit phase, as it makes sure, the component has already been rendered once for D3 to being able to select the existing real SVG DOM node. The second important life cycle method is \texttt{componentDidUpdate()} which provides the latest most up to date data directly to D3. That way D3 can then handle the update in the force graph.

\subsubsection{Implmentation details}

\begin{program}
\caption{Pure D3 force graph initializing function}
\label{prog:pureD3InitFn}
\begin{JsCode}
initGraph = () => {
  const { width, height, onSimulationStart } = this.props

  onSimulationStart()

  const svg = select(this.ref.current)
  svg
    .append('g')
    .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')')

  const simOptions = this.extractSimOptions()
  const { simulation, updateSimulation } = buildForceSimulation({
    type: SIMULATION_TYPE.PURE_D3,
    ...simOptions,
  })

  this.simulation = simulation
  this.updateSimulation = updateSimulation
}
\end{JsCode}
\end{program}

\begin{program}
\caption{Function that applies the data update to D3 on data changes}
\label{prog:pureD3updateApply}
\begin{JsCode}
applyNodeUpdateCycle = (simulation) => {
  simulation.linkSel.exit().remove()
  
  simulation.linkSel = simulation.linkSel
    .enter()
    .append('path')
    .attr('stroke', '#45b29d')
    .attr('fill', 'none')
    .merge(simulation.linkSel)
  
  let t = transition().duration(750)
  
  simulation.nodeSel
    .exit()
    .style('fill', '#b26745')
    .transition(t)
    .attr('r', 1e-6)
    .remove()
  
  simulation.nodeSel
    .transition(t)
    .style('fill', '#3a403d')
    .attr('r', ({ size }) => size)
  
  simulation.nodeSel = simulation.nodeSel
    .enter()
    .append('circle')
    .style('fill', '#45b29d')
    .attr('r', ({ size }) => size)
    .attr('id', ({ name }) => name)
    .merge(simulation.nodeSel)
}
\end{JsCode}
\end{program}

\begin{program}
\caption{Tick handling function of the pure D3 prototype}
\label{prog:pureD3Tick}
\begin{JsCode}
ticked = () => {
  this.simulation.nodeSel.attr('cx', ({ x }) => x).attr('cy', ({ y }) => y)
  this.simulation.linkSel.attr('d', (d) =>
    this.props.linkType === LINK_TYPES.CURVED ? getCurvedLinkPath(d) : getStraightLinkPath(d),
  )
}
\end{JsCode}
\end{program}

Once the component is initialized, the \texttt{componentDidMount()} lifecycle method directly calls the initializer function which can be seen on line 1 in the code snippet in \ref{prog:pureD3InitFn}. The initializing function appends the base \texttt{<g>} tag and also handles the translation of the current height and width of the component. Then the \texttt{buildForceSimulation()} function is called with the current options and parameters in order to get the simulation and the correct updater function. Note how the simulation type is passed to the builder function as well. The resulting simulation and updater function is then saved in the current component.

What is also worth mentioning is the fact, that the simulation and the updating function are saved directly to the \texttt{this} context as seen in line 12 of the code snippet in \ref{prog:d3forceinit}. As stateful components are just plain JavaScript classes, they're capable of having member variables as well. It is of utmost importance not to confuse member variables with React's component state, as React is agnostic to class member variables. React not noticing the member variables is a wanted effect in this case, as the simulation and the updater function have to be saved in the component without React going through a new render cycle. 

Looking at the code in \ref{prog:pureD3updateApply}, the update applying functionality can be seen very well. If given a current simulation object, the function handles all newly entering, transitioning, and exiting nodes accordingly. Even an animation is applied. Each time, the pure D3 react component has updated through the \texttt{componentDidUpdate()} function, the \texttt{applyNodeUpdateCycle()} function is called. The force simulation building module can take in the updater function and composes it directly into the updating function as seen in line 14 in \ref{prog:forceBuildModule}.

Another vital function of the pure D3 force graph is the tick handler that can be seen in the code snippet in \ref{prog:pureD3Tick}. The ticking function also gets passed to the force simulation builder function. Each iteration of D3's simulation tick the function then updates the position of all nodes and links in the simulation.

\subsubsection{Advantages}

One of the most apparent advantages of the pure D3 force graph implementation is its performance, of course. Since the implementation uses a native D3 approach to render and update the nodes and links in the simulation, the performance is also comparable to a native D3 implementation. In chapter \ref{cha:performance}, the performance is compared to other implementations as well.

\subsubsection{Disadvantages}

The most significant Disadvantage with the pure D3 implementation is the fact that all DOM manipulations are handled via imperatively chained function calls on the node selections of D3 which also implies, that the node rendering cannot be customized via passing custom render functions for instance. The force graph's code itself has to be changed to get different node and link appearances, which leads to the previously described problem of encountering unmaintainable code over time.

\subsection{Pure React prototype}

Pure React implementation

\subsection{D3 and React hybrid}

% react move

Hybrid implementation.

\section{Comparison of the different proposed Prototypes}

The implementation of the prototypes is explained.

\section{Building a stable Testing Environment}

The testing environment is explained. Request animation frame testing is explained as well.

\section{Testing methodologies}

I describe how i tested the whole thing

\section{Testing devices}

What devices did i benchmark my prototypes on?
